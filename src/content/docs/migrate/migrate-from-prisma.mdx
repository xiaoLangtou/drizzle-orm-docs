---
title: "ä» Prisma è¿ç§»åˆ° Drizzle"
---
import Steps from "@mdx/Steps.astro";
import Npm from "@mdx/Npm.astro";

## å…¥é—¨

æœ¬æŒ‡å—æä¾›äº†ä¸€ä¸ªå°†åŸºæœ¬çš„ **Prisma** é¡¹ç›®è¿ç§»åˆ° **Drizzle ORM** çš„ç›´æ¥æ–¹æ³•ã€‚è™½ç„¶ç¤ºä¾‹ä¸»è¦å…³æ³¨ `PostgreSQL`ï¼Œä½†è¿™ä¸ªè¿‡ç¨‹å¯¹å…¶ä»–æ”¯æŒçš„æ•°æ®åº“ä¹Ÿæ˜¯ç±»ä¼¼çš„ã€‚

### è¿ç§»è¿‡ç¨‹æ¦‚è¿°

æ— è®ºä½ çš„åº”ç”¨ç±»å‹æˆ– API å±‚å¦‚ä½•ï¼Œä» **Prisma** è¿ç§»åˆ° **Drizzle ORM** çš„æ­¥éª¤éƒ½ä¿æŒä¸€è‡´ï¼š

1. å®‰è£… **Drizzle ORM** å’Œ **Drizzle Kit**
2. è®¾ç½® **Drizzle config** æ–‡ä»¶
3. æ£€æŸ¥ä½ çš„æ•°æ®åº“
4. å°† **Drizzle ORM** è¿æ¥åˆ°ä½ çš„æ•°æ®åº“
5. å°†ä½ çš„ **Prisma** æŸ¥è¯¢è½¬æ¢ä¸º **Drizzle ORM** æŸ¥è¯¢

è¿™äº›æ­¥éª¤é€‚ç”¨äºæ— è®ºä½ æ˜¯åœ¨å¼€å‘ REST APIï¼ˆä¾‹å¦‚ï¼Œä½¿ç”¨ Expressã€Koa æˆ– NestJSï¼‰è¿˜æ˜¯ä½¿ç”¨ **Prisma** è¿›è¡Œæ•°æ®åº“äº¤äº’çš„ä»»ä½•å…¶ä»–ç±»å‹çš„åº”ç”¨ç¨‹åºã€‚

## Prisma é¡¹ç›®æ¦‚è¿°

åœ¨æœ¬æŒ‡å—ä¸­ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ä¸€ä¸ªç”¨ `Express` æ„å»ºçš„ REST API ä½œä¸ºç¤ºä¾‹é¡¹ç›®æ¥è¿ç§»åˆ° **Drizzle ORM**ã€‚å®ƒæœ‰å››ä¸ªå®ä½“ï¼š

```prisma  copy filename="prisma/schema.prisma" collapsable
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}


model Product {
  id              Int           @id @default(autoincrement())
  name            String
  supplierId      Int
  unitPrice       Decimal       @db.Decimal(10, 4)
  unitsInStock    Int

  supplier        Supplier?     @relation(fields: [supplierId], references: [id])
  orderDetails    OrderDetail[]

  @@map("products")
}

model Supplier {
  id           Int       @id @default(autoincrement())
  companyName  String
  city         String
  country      String

  products     Product[]

  @@map("suppliers")
}

model OrderDetail {
  orderId   Int
  productId Int
  quantity  Int

  order   Order   @relation(fields: [orderId], references: [id])
  product Product @relation(fields: [productId], references: [id])

  @@id([orderId, productId])
  @@map("order_details")
}

model Order {
  id             Int       @id @default(autoincrement())
  orderDate      DateTime  @db.Date
  shippedDate    DateTime? @db.Date
  shipAddress    String
  shipPostalCode String?
  shipCountry    String

  orderDetails OrderDetail[]

  @@map("orders")
}
```

è¿™äº›æ¨¡å‹æœ‰ä»¥ä¸‹å…³ç³»ï¼š

1. `Supplier` å’Œ `Product` ä¹‹é—´çš„ `ä¸€å¯¹å¤š` å…³ç³»
2. `Order` å’Œ `Product` ä¹‹é—´çš„ `å¤šå¯¹å¤š` å…³ç³»

å¯¹äº `å¤šå¯¹å¤š` å…³ç³»ï¼Œæˆ‘ä»¬å°†åˆ›å»ºä¸€ä¸ªè¿æ¥è¡¨ `order_details`ï¼Œè¿™æ · `Order` å’Œ `Product` å®ä½“å°†ä¸ `OrderDetail` å®ä½“æœ‰ `ä¸€å¯¹å¤š` å…³ç³»ã€‚

ç›¸åº”çš„è¡¨å·²ç»ä½¿ç”¨ç”Ÿæˆçš„ Prisma è¿ç§»åˆ›å»ºã€‚


```sql copy filename="prisma/migrations/20240101200233_init/migration.sql" collapsable
-- CreateTable
CREATE TABLE "products" (
    "id" SERIAL NOT NULL,
    "name" TEXT NOT NULL,
    "supplierId" INTEGER NOT NULL,
    "unitPrice" DECIMAL(10,4) NOT NULL,
    "unitsInStock" INTEGER NOT NULL,

    CONSTRAINT "products_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "suppliers" (
    "id" SERIAL NOT NULL,
    "companyName" TEXT NOT NULL,
    "city" TEXT NOT NULL,
    "country" TEXT NOT NULL,

    CONSTRAINT "suppliers_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "order_details" (
    "orderId" INTEGER NOT NULL,
    "productId" INTEGER NOT NULL,
    "quantity" INTEGER NOT NULL,

    CONSTRAINT "order_details_pkey" PRIMARY KEY ("orderId","productId")
);

-- CreateTable
CREATE TABLE "orders" (
    "id" SERIAL NOT NULL,
    "orderDate" DATE NOT NULL,
    "shippedDate" DATE,
    "shipAddress" TEXT NOT NULL,
    "shipPostalCode" TEXT,
    "shipCountry" TEXT NOT NULL,

    CONSTRAINT "orders_pkey" PRIMARY KEY ("id")
);

-- AddForeignKey
ALTER TABLE "products" ADD CONSTRAINT "products_supplierId_fkey" FOREIGN KEY ("supplierId") REFERENCES "suppliers"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "order_details" ADD CONSTRAINT "order_details_orderId_fkey" FOREIGN KEY ("orderId") REFERENCES "orders"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "order_details" ADD CONSTRAINT "order_details_productId_fkey" FOREIGN KEY ("productId") REFERENCES "products"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
```

æœ¬æŒ‡å—ä½¿ç”¨ä»¥ä¸‹æ–‡ä»¶ç»“æ„ï¼š

```plaintext
ğŸ“¦ <project root>
 â”œ ğŸ“‚ prisma
 â”‚  â”œ ğŸ“‚ migrations
 â”‚  â”‚  â”œ ğŸ“‚ 20240101200233_init
 â”‚  â”‚  â”‚  â”” ğŸ“œ migration.sql
 â”‚  â”‚  â”” ğŸ“œ migration_lock.toml
 â”‚  â”” ğŸ“œ schema.prisma
 â”œ ğŸ“‚ src
 â”‚  â”œ ğŸ“‚ db
 â”‚  â”‚  â”” ğŸ“œ db.ts
 â”‚  â”œ ğŸ“‚ routers
 â”‚  â”‚  â”œ ğŸ“œ order.router.ts
 â”‚  â”‚  â”œ ğŸ“œ product.router.ts
 â”‚  â”‚  â”” ğŸ“œ supplier.router.ts
 â”‚  â”œ ğŸ“‚ controllers
 â”‚  â”‚  â”œ ğŸ“œ order.controller.ts
 â”‚  â”‚  â”œ ğŸ“œ product.controller.ts
 â”‚  â”‚  â”” ğŸ“œ supplier.controller.ts
 â”‚  â”œ ğŸ“œ index.ts
 â”‚  â”” ğŸ“œ server.ts
 â”œ ğŸ“œ package.json
 â”” ğŸ“œ tsconfig.json
```

<Steps>

#### å®‰è£… Drizzle ORM & Drizzle Kit

ç¬¬ä¸€æ­¥æ˜¯å®‰è£… **Drizzle ORM** å’Œ `pg` åŒ…ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨å®ƒä½œä¸ºé©±åŠ¨ç¨‹åºã€‚ç¬¬äºŒæ­¥æ˜¯å®‰è£… **Drizzle Kit** å’Œ `pg` çš„ç±»å‹å®šä¹‰ã€‚[Drizzle Kit](/docs/kit-overview) - ç”¨äºè‡ªåŠ¨ç”Ÿæˆ SQL è¿ç§»å’Œå¿«é€ŸåŸå‹è®¾è®¡çš„ CLI å·¥å…·ã€‚

<Npm>
drizzle-orm pg
-D drizzle-kit @types/pg
</Npm>

#### è®¾ç½® Drizzle config æ–‡ä»¶

**Drizzle config** - ä¸€ä¸ªé…ç½®æ–‡ä»¶ï¼Œç”± **Drizzle Kit** ä½¿ç”¨ï¼ŒåŒ…å«äº†æ‰€æœ‰å…³äºä½ çš„æ•°æ®åº“è¿æ¥ã€è¿ç§»æ–‡ä»¶å¤¹å’Œæ¨¡å¼æ–‡ä»¶çš„ä¿¡æ¯ã€‚

åœ¨ä½ çš„é¡¹ç›®æ ¹ç›®å½•åˆ›å»ºä¸€ä¸ª `drizzle.config.ts` æ–‡ä»¶å¹¶æ·»åŠ ä»¥ä¸‹å†…å®¹ï¼š

```typescript copy filename="drizzle.config.ts"
import 'dotenv/config'; // ç¡®ä¿å®‰è£… dotenv åŒ…
import { defineConfig } from 'drizzle-kit';

export default defineConfig({
  dialect: 'postgresql',
  out: './src/drizzle',
  schema: './src/drizzle/schema.ts',
  dbCredentials: {
    host: process.env.DB_HOST!,
    port: Number(process.env.DB_PORT!),
    user: process.env.DB_USERNAME!,
    password: process.env.DB_PASSWORD!,
    database: process.env.DB_NAME!,
  },
  // æ‰“å°æ‰€æœ‰è¯­å¥
  verbose: true,
  // æ€»æ˜¯è¯·æ±‚ç¡®è®¤
  strict: true,
});
```
#### æ£€æŸ¥ä½ çš„æ•°æ®åº“

**Drizzle Kit** æä¾›äº†ä¸€ä¸ª CLI å‘½ä»¤æ¥æ£€æŸ¥ä½ çš„æ•°æ®åº“å¹¶ç”Ÿæˆæ¨¡å¼æ–‡ä»¶ã€‚æ¨¡å¼æ–‡ä»¶åŒ…å«äº†æ‰€æœ‰å…³äºä½ çš„æ•°æ®åº“è¡¨ã€åˆ—ã€å…³ç³»å’Œç´¢å¼•çš„ä¿¡æ¯ã€‚

```bash
npx drizzle-kit introspect
```

è¿™ä¸ªå‘½ä»¤å°†åœ¨ src/drizzle æ–‡ä»¶å¤¹ä¸­ç”Ÿæˆä¸€ä¸ª schema.ts æ–‡ä»¶ï¼Œä»¥åŠå¿«ç…§å’Œè¿ç§»æ–‡ä»¶ã€‚

```typescript collapsable copy filename="src/drizzle/schema.ts"
import {
  pgTable,
  varchar,
  timestamp,
  text,
  integer,
  serial,
  foreignKey,
  numeric,
  date,
  primaryKey,
} from 'drizzle-orm/pg-core';
import { sql } from 'drizzle-orm';

export const prismaMigrations = pgTable('_prisma_migrations', {
  id: varchar('id', { length: 36 }).primaryKey().notNull(),
  checksum: varchar('checksum', { length: 64 }).notNull(),
  finishedAt: timestamp('finished_at', { withTimezone: true, mode: 'string' }),
  migrationName: varchar('migration_name', { length: 255 }).notNull(),
  logs: text('logs'),
  rolledBackAt: timestamp('rolled_back_at', { withTimezone: true, mode: 'string' }),
  startedAt: timestamp('started_at', { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
  appliedStepsCount: integer('applied_steps_count').default(0).notNull(),
});

export const suppliers = pgTable('suppliers', {
  id: serial('id').primaryKey().notNull(),
  companyName: text('companyName').notNull(),
  city: text('city').notNull(),
  country: text('country').notNull(),
});

export const products = pgTable('products', {
  id: serial('id').primaryKey().notNull(),
  name: text('name').notNull(),
  supplierId: integer('supplierId')
    .notNull()
    .references(() => suppliers.id, { onDelete: 'restrict', onUpdate: 'cascade' }),
  unitPrice: numeric('unitPrice', { precision: 10, scale: 4 }).notNull(),
  unitsInStock: integer('unitsInStock').notNull(),
});

export const orders = pgTable('orders', {
  id: serial('id').primaryKey().notNull(),
  orderDate: date('orderDate').notNull(),
  shippedDate: date('shippedDate'),
  shipAddress: text('shipAddress').notNull(),
  shipPostalCode: text('shipPostalCode'),
  shipCountry: text('shipCountry').notNull(),
});

export const orderDetails = pgTable(
  'order_details',
  {
    orderId: integer('orderId')
      .notNull()
      .references(() => orders.id, { onDelete: 'restrict', onUpdate: 'cascade' }),
    productId: integer('productId')
      .notNull()
      .references(() => products.id, { onDelete: 'restrict', onUpdate: 'cascade' }),
    quantity: integer('quantity').notNull(),
  },
  (table) => [
    primaryKey({ columns: [table.orderId, table.productId], name: 'order_details_pkey' })
  ]
);
```

```sql collapsable copy filename="src/drizzle/0000_cool_puff_adder.sql"
CREATE TABLE IF NOT EXISTS "_prisma_migrations" (
	"id" varchar(36) PRIMARY KEY NOT NULL,
	"checksum" varchar(64) NOT NULL,
	"finished_at" timestamp with time zone,
	"migration_name" varchar(255) NOT NULL,
	"logs" text,
	"rolled_back_at" timestamp with time zone,
	"started_at" timestamp with time zone DEFAULT now() NOT NULL,
	"applied_steps_count" integer DEFAULT 0 NOT NULL
);
--> statement-breakpoint
CREATE TABLE IF NOT EXISTS "suppliers" (
	"id" serial PRIMARY KEY NOT NULL,
	"companyName" text NOT NULL,
	"city" text NOT NULL,
	"country" text NOT NULL
);
--> statement-breakpoint
CREATE TABLE IF NOT EXISTS "products" (
	"id" serial PRIMARY KEY NOT NULL,
	"name" text NOT NULL,
	"supplierId" integer NOT NULL,
	"unitPrice" numeric(10, 4) NOT NULL,
	"unitsInStock" integer NOT NULL
);
--> statement-breakpoint
CREATE TABLE IF NOT EXISTS "orders" (
	"id" serial PRIMARY KEY NOT NULL,
	"orderDate" date NOT NULL,
	"shippedDate" date,
	"shipAddress" text NOT NULL,
	"shipPostalCode" text,
	"shipCountry" text NOT NULL
);
--> statement-breakpoint
CREATE TABLE IF NOT EXISTS "order_details" (
	"orderId" integer NOT NULL,
	"productId" integer NOT NULL,
	"quantity" integer NOT NULL,
	CONSTRAINT order_details_pkey PRIMARY KEY("orderId","productId")
);
--> statement-breakpoint
DO $$ BEGIN
 ALTER TABLE "products" ADD CONSTRAINT "products_supplierId_fkey" FOREIGN KEY ("supplierId") REFERENCES "suppliers"("id") ON DELETE restrict ON UPDATE cascade;
EXCEPTION
 WHEN duplicate_object THEN null;
END $$;
--> statement-breakpoint
DO $$ BEGIN
 ALTER TABLE "order_details" ADD CONSTRAINT "order_details_orderId_fkey" FOREIGN KEY ("orderId") REFERENCES "orders"("id") ON DELETE restrict ON UPDATE cascade;
EXCEPTION
 WHEN duplicate_object THEN null;
END $$;
--> statement-breakpoint
DO $$ BEGIN
 ALTER TABLE "order_details" ADD CONSTRAINT "order_details_productId_fkey" FOREIGN KEY ("productId") REFERENCES "products"("id") ON DELETE restrict ON UPDATE cascade;
EXCEPTION
 WHEN duplicate_object THEN null;
END $$;
```

å¦å¤–ï¼Œå¦‚æœä½ æƒ³ä½¿ç”¨å…³ç³»æŸ¥è¯¢ï¼Œä½ å¿…é¡»ç”¨å…³ç³»è¡¨æ›´æ–°ä½ çš„æ¨¡å¼æ–‡ä»¶ï¼š

```typescript copy filename="src/drizzle/schema.ts"
// ...å…¶ä»–å¯¼å…¥
import { relations } from 'drizzle-orm';

// ...å…¶ä»–è¡¨
export const suppliersRelations = relations(suppliers, ({ many }) => ({
  products: many(products),
}));

export const productsRelations = relations(products, ({ one, many }) => ({
  supplier: one(suppliers, { fields: [products.supplierId], references: [suppliers.id] }),
  orderDetails: many(orderDetails),
}));

export const ordersRelations = relations(orders, ({ many }) => ({
  orderDetails: many(orderDetails),
}));

export const orderDetailsRelations = relations(orderDetails, ({ one }) => ({
  order: one(orders, { fields: [orderDetails.orderId], references: [orders.id] }),
  product: one(products, { fields: [orderDetails.productId], references: [products.id] }),
}));
```

ç°åœ¨æˆ‘ä»¬æœ‰äº†ä»¥ä¸‹æ–‡ä»¶ç»“æ„ï¼š

```plaintext
ğŸ“¦ <project root>
 â”œ ğŸ“‚ src
 â”‚  â”œ ğŸ“‚ drizzle
 â”‚  â”‚  â”œ ğŸ“‚ meta
 |  |  |  â”œ ğŸ“œ _journal.json
 â”‚  â”‚  â”‚  â”” ğŸ“œ 0000_snapshot.json
 â”‚  â”‚  â”œ ğŸ“œ 0000_cool_puff_adder.sql
 â”‚  â”‚  â”” ğŸ“œ schema.ts
 â”‚  â”œ ğŸ“‚ routers
 â”‚  â”‚  â”œ ğŸ“œ order.router.ts
 â”‚  â”‚  â”œ ğŸ“œ product.router.ts
 â”‚  â”‚  â”” ğŸ“œ supplier.router.ts
 â”‚  â”œ ğŸ“‚ controllers
 â”‚  â”‚  â”œ ğŸ“œ order.controller.ts
 â”‚  â”‚  â”œ ğŸ“œ product.controller.ts
 â”‚  â”‚  â”” ğŸ“œ supplier.controller.ts
 â”‚  â”œ ğŸ“œ index.ts
 â”‚  â”” ğŸ“œ server.ts
 â”œ ğŸ“œ package.json
 â”œ ğŸ“œ drizzle.config.ts
 â”” ğŸ“œ tsconfig.json
```

#### å°† Drizzle ORM è¿æ¥åˆ°ä½ çš„æ•°æ®åº“

åœ¨ `src/drizzle` æ–‡ä»¶å¤¹ä¸­åˆ›å»ºä¸€ä¸ª `db.ts` æ–‡ä»¶å¹¶è®¾ç½®ä½ çš„æ•°æ®åº“é…ç½®ï¼š

```typescript copy filename="src/drizzle/db.ts"
import { drizzle } from 'drizzle-orm/node-postgres';
import { Client } from 'pg';
import * as schema from './schema';

export const client = new Client({
  host: process.env.DB_HOST!,
  port: Number(process.env.DB_PORT!),
  user: process.env.DB_USERNAME!,
  password: process.env.DB_PASSWORD!,
  database: process.env.DB_NAME!,
});

// { schema } ç”¨äºå…³ç³»æŸ¥è¯¢
export const db = drizzle({ client, schema });
```

```typescript copy filename="src/index.ts"
import 'dotenv/config';
import { client, db } from './drizzle/db';
import { resolve } from 'node:path';
import { migrate } from 'drizzle-orm/node-postgres/migrator';


(async () => {
  await client.connect();

  // è¿™ä¸ªå‘½ä»¤ä¼šè¿è¡Œè¿ç§»æ–‡ä»¶å¤¹ä¸­çš„æ‰€æœ‰è¿ç§»å¹¶å°†æ›´æ”¹åº”ç”¨åˆ°æ•°æ®åº“
  await migrate(db, { migrationsFolder: resolve(__dirname, './drizzle') });

  // ... å¯åŠ¨ä½ çš„åº”ç”¨
})();
```

#### å°†ä½ çš„ Prisma æŸ¥è¯¢è½¬æ¢ä¸º Drizzle ORM æŸ¥è¯¢

åœ¨æœ¬èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†å‘ä½ å±•ç¤ºå¦‚ä½•å°†å‡ ä¸ª **Prisma** æŸ¥è¯¢æ›¿æ¢ä¸º **Drizzle ORM** æŸ¥è¯¢ã€‚

##### æ›¿æ¢æ’å…¥æŸ¥è¯¢

æˆ‘ä»¬å°†å±•ç¤ºå¦‚ä½•å‘ `suppliers` å’Œ `products` è¡¨æ’å…¥æ–°è¡Œã€‚

1. `POST /suppliers`
```typescript copy filename="src/controllers/supplier.controller.ts"
import { prisma } from '../db/db';

await prisma.supplier.createMany({
  data: [
    { companyName: 'TestCompanyName1', city: 'TestCity1', country: 'TestCountry1' },
    { companyName: 'TestCompanyName2', city: 'TestCity2', country: 'TestCountry2' },
  ],
});
```

ä½¿ç”¨ **Drizzle ORM**ï¼ŒæŸ¥è¯¢å®ç°å¦‚ä¸‹ï¼š

```typescript copy filename="src/controllers/supplier.controller.ts"
import { db } from '../drizzle/db';
import { suppliers } from '../drizzle/schema';

await db.insert(suppliers).values([
  {
    companyName: 'TestCompanyName1',
    city: 'TestCity1',
    country: 'TestCountry1',
  },
  {
    companyName: 'TestCompanyName2',
    city: 'TestCity2',
    country: 'TestCountry2',
  },
]);
```

2. `POST /products`

```typescript copy filename="src/controllers/product.controller.ts"
import { prisma } from '../db/db';

await prisma.product.createMany({
  data: [
    { 
      name: 'TestProductName1',
      supplierId: 1,
      unitPrice: 10,
      unitsInStock: 20,
    },
    {
      name: 'TestProductName2',
      supplierId: 1,
      unitPrice: 25,
      unitsInStock: 7,
    },
    {
      name: 'TestProductName3',
      supplierId: 2,
      unitPrice: 50,
      unitsInStock: 17,
    },
    {
      name: 'TestProductName4',
      supplierId: 2,
      unitPrice: 100,
      unitsInStock: 2,
    },
  ],
});
```

ä½¿ç”¨ **Drizzle ORM**ï¼ŒæŸ¥è¯¢å®ç°å¦‚ä¸‹ï¼š

æ³¨æ„ `unitPrice` å­—æ®µã€‚åœ¨ **Prisma** ä¸­å®ƒæ˜¯ä¸€ä¸ª `number` ç±»å‹ï¼Œä½†åœ¨ **Drizzle ORM** ä¸­å®ƒæ˜¯ä¸€ä¸ª `string` ç±»å‹ï¼Œå¯ä»¥å¤„ç†å°æ•°ç‚¹åè¶…è¿‡ 16383 ä½æ•°å­—ï¼Œè¿™æ˜¯ `number` ç±»å‹æ‰€ä¸èƒ½åšåˆ°çš„ã€‚

```typescript copy filename="src/controllers/product.controller.ts"
await db.insert(products).values([
  {
    name: 'TestProductName1',
    supplierId: 1,
    unitPrice: '10',
    unitsInStock: 20,
  },
  {
    name: 'TestProductName2',
    supplierId: 1,
    unitPrice: '25',
    unitsInStock: 7,
  },
  {
    name: 'TestProductName3',
    supplierId: 2,
    unitPrice: '50',
    unitsInStock: 17,
  },
  {
    name: 'TestProductName4',
    supplierId: 2,
    unitPrice: '100',
    unitsInStock: 2,
  },
]);
```
</Steps>
